module.exports = (function(){
  /* Generated by PEG.js 0.6.2 (http://pegjs.majda.cz/). */
  /* Compact-Result modification. */
  
  /* UTILS */
  
  function pad(input, padding, length) {
    var result = input;
    
    var plen = length - input.length;
      for (var i = 0; i < plen; i++) {
        result = padding + result;
      }
    
    return result;
  }
  
  function escape(ch) {
    var ccode = ch.charCodeAt(0);
    return '\\' + ((ccode <= 0xFF) ? 'x' : 'u') +
           pad(ccode.toString(16).toUpperCase(), '0',
               ((ccode <= 0xFF) ? 2 : 4));
    }
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
    return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  function merge(to,from) {
    for (var key in from) { to[key] = from[key]; };
  }
  
  /* CONTEXT */
  
  // load variables from some object into
  // specified level of context
  function ctx_load(ctx, lvl, obj) {
    if (!ctx[lvl]) ctx[lvl] = {};
    merge(ctx[lvl], obj);
  }
  // collect all variables from context at specified
  // level and straight lower to 0, and return the
  // result
  function ctx_get(ctx, lvl) {
    var c = {};
    for (var i = lvl; i >= 0; i--) {
      merge(c,ctx[i]);
    }
    return c;
  }
  // collect all variables from context at specified
  // level and straight lower to 0, and inject into
  // specified object
  function ctx_inject(ctx, lvl, target) {
    for (var i = lvl; i >= 0; i--) {
      merge(target,ctx[i]);
    }
  }
  
  /* VARIABLES */
  
  var rules = {},
      names = {};
  
  var pos, // 0
      failures, // {}
      deep, // 1
      cache, // {}
      ctx, // []
      target = this,
      _g = this;
  
  /* FAILURES */
  
  function failed(failure) {
    if (pos < failures.rightest) {
      return;
    }
    
    if (pos > failures.rightest) {
      failures.rightest = pos;
      failures.expected = [];
    }
    
    failures.expected.push(failure);
  }
  
  function uniqueList(expected) {
    expected.sort();
    
    var last = null;
    var unique = [];
    for (var i = 0; i < expected.length; i++) {
      if (expected[i] !== last) {
        unique.push(expected[i]);
        last = expected[i];
      }
    }
    
    switch (unique.length) {
      case 0:
        return "end of input";
      case 1:
        return unique[0];
      default:
        return unique.slice(0, unique.length - 1).join(", ")
          + " or "
          + unique[unique.length - 1];
    }
  }
  
  function errorMsg() {
    var expected = uniqueList(failures.expected),
        actualPos = Math.max(pos, failures.rightest),
        actual = (actualPos < input.length)
                 ? quote(input.charAt(actualPos))
                 : "end of input";
    
    return "Expected " + expected + " but " + actual + " found.";
  }
  
  function findErrPos() {
    /*
     * The first idea was to use |String.split| to break the input up to the
     * error position along newlines and derive the line and column from
     * there. However IE's |split| implementation is so broken that it was
     * enough to prevent it.
     */
    
    var line = 1;
    var column = 1;
    var seenCR = false;
    
    for (var i = 0; i < Math.max(pos, failures.rightest); i++) {
      var ch = input.charAt(i);
      if (ch === "\n") {
        if (!seenCR) { line++; }
        column = 1;
        seenCR = false;
      } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
        line++;
        column = 1;
        seenCR = true;
      } else {
        column++;
        seenCR = false;
      }
    }
    
    return [ line, column ];
  }
  
  /* CACHE */
  
  function inCache(name) {
    return cache.hasOwnProperty(name+"@"+pos);
  }
  
  /* must be used only next to inCache check in a way like:
   * if (inCache(name)) return fromCache(name); */
  function fromCache(name) {
    var cached = cache[name+"@"+pos];
    pos = cached.next
    return cached.result;
  }
  
  /* must be used only next to inCache check in a way like:
   * if (!inCache(name)) return toCache(name, rule()); */
  function toCache(name, result) {
    var res = {
      "next": pos,
      "result": result
    };
    cache[name+"@"+pos] = res;
    return res;
  }

  /* PEFORMERS */

  function bind(f, args) { 
    return function() {
        return f.apply(null, args);
    };
  }

  function wrap(f) {
    return function() {
      return bind(f, arguments);
    }
  }

  function exec(f) {
      console.log('exec');
  }
  var _try = exec;

  function ref(rule) { // just calls a rule
    console.log('rule-bind');
  }
  ref = wrap(ref);

  function sequence(/*f...*/) {
    console.log('sequence');
  }
  // TODO: do this stuff in single loop
  sequence = wrap(sequence);

  function any(f) {
    console.log('any');
  }
  any = wrap(any);

  function some(f) {
    console.log('some');
  }
  some = wrap(some);

  function action(f, code) {
    console.log('action'); 
  }
  action = wrap(action);

  function choice(/*f...*/) {
    console.log('choice'); 
  }
  choice = wrap(choice);

  function match(str) {
    console.log('match', str);  
  }
  match = wrap(match);

  function imatch(re) {
    console.log('imatch', re);  
  }
  imatch = wrap(imatch);

  function label(lbl, f) {
    console.log('label', lbl);
  }
  label = wrap(label);

  function maybe(f) {
    console.log('maybe'); 
  }
  maybe = wrap(maybe);

  function not(f) {
    console.log('not'); 
  }
  not = wrap(not);

  function and(f) {
    console.log('and'); 
  }
  and = wrap(and);

  function pre(code) {
    console.log('pre'); 
  }
  pre = wrap(pre);

  function xpre(code) {
    console.log('xpre'); 
  }
  xpre = wrap(xpre);
  
  /* INITIALIZER */
  
  function initialize() {
     console.log("initializer");
      return { foo: 11 }; 
  }
  
  /* RULES DEFINITIONS */
  
  rules.start = function() {
    _try(
      action(
        any(
          ref(rules.a)
        ),
        function() {
           console.log(foo); 
        }
      )
    );
  }
  
  rules.a = function() {
    _try(
      sequence(
        ref(rules.w),
        some(
          ref(rules.m)
        ),
        any(
          action(
            choice(
              match("b"),
              label("d",
                match("c")
              )
            ),
            function() {
               return d; 
            }
          )
        )
      )
    );
  }
  
  rules.w = function() {
    _try(
      some(
        action(
          ref(rules.c),
          function() {
             console.log('test'); 
          }
        )
      )
    );
  }
  
  rules.c = function() {
    _try(
      choice(
        match("a"),
        match("e"),
        ref(rules.g)
      )
    );
  }
  
  rules.g = function() {
    _try(
      imatch(/oooo/i)
    );
  }
  
  rules.m = function() {
    _try(
      sequence(
        match("a"),
        maybe(
          ref(rules.n)
        )
      )
    );
  }
  
  rules.n = function() {
    _try(
      label("d",
        action(
          sequence(
            some(
              ref(rules.b)
            ),
            ref(rules.e),
            ref(rules.f)
          ),
          function() {
             return "aa"; 
          }
        )
      )
    );
  }
  
  rules.b = function() {
    _try(
      match("wee")
    );
  }
  
  rules.e = function() {
    _try(
      sequence(
        match("meeh"),
        ref(rules.one_char),
        label("f",
          not(
            ref(rules.one_char)
          )
        )
      )
    );
  }
  
  rules.f = function() {
    _try(
      choice(
        match("foo"),
        and(
          ref(rules.two_strange_chars)
        )
      )
    );
  }
  names.f="foo";
  
  rules.one_char = function() {
    _try(
      sequence(
        xpre(function() {
           console.log("not predicate"); console.log(foo); return false; 
        }),
        char()
      )
    );
  }
  
  rules.two_strange_chars = function() {
    _try(
      sequence(
        pre(function() {
           console.log("predicate"); return true; 
        }),
        re(/^[a-n]/i, "[a-n]i"),
        re(/^[^A-Z]/, "[^A-Z]")
      )
    );
  }
  names.two_strange_chars="tsc";
  
  /* RULES WRAPPER */
  
  for (rule in rules) {
    rules[rule] = (function(name, rule) { return function() {
      //if (inCache(name)) return fromCache(name);
      //ctx_inject(ctx, deep, target);
      //return toCache(name, rule());
      rule();
    }; })(rule, rules[rule]);
  }
  
  /* RESULT OBJECT + PARSE FUNCTION */
  
  var g = this;
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      
      // initialize variables
      pos = 0, deep = 1, cache = {}, ctx = []
      failures = { rightest: 0, expected: [] },
      g.input = input;
      
      // load object returned from initializer into zero-level of context
      //ctx_load(ctx, 0, initialize());
      initialize();
      
      // find start rule
      if (startRule !== undefined) {
        if (rules[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      // and execute it
      var result = rules[startRule]();
      
      if (result === null || pos !== input.length) {
        throw new this.SyntaxError(
          errorMsg(), findErrPos()
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(message, errPos) {
    this.name = "SyntaxError";
    this.message = message;
    this.line = errPos[0];
    this.column = errPos[1];
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
