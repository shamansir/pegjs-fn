module.exports = (function(){
  /* Generated by PEG.js-fn 0.1.0, Functional modification by shaman.sir@gmail.com (http://shamansir.github.io/pegjs-fn/). */
  /* Original version developed by David Majda (http://pegjs.majda.cz/) */

  /* ########### ENVIRONMENT ########### */

  var input,
      options;

  var pos, // 0, parser position
      p_pos; // 0, previous parser position


  // This code encloses all of the user blocks (initializer and/or actions)
  // in their own sandbox, so if there is an initializer, its inner variables
  // will [only] be accessible to actions; this, however, requires an initializer
  // not to have any first-level return statements. Also, this approach keeps parser
  // inner variables safe from user access, except the ones defined above.
  var __p_blocks = (function() { return function() {

    // backwards compatibility with original peg-js
    function offset() { return p_pos; }
    function text() { return input.substring(p_pos, pos); }

    /* ########### USER CODE ########### */


    /* ----------- INITIALIZER ----------- */

      var utils = require("./utils");


    /* ----------- BLOCKS ----------- */

    // Blocks are grouped by rule name and id; they all get access to current context
    // through $ctx variable which they expand into their arguments. Arguments
    // names are precalculated during parser generation process.

    // $f and $ctx variables are named so creepy just to ensure that parser writer will not use them
    // for naming variables in his code (only $ctx may clash in this architecture, in fact),
    // we hope any modern environment supports Unicode now

    return {
      "grammar": [
        function($ctx) {
          // grammar[0]
          return (function(initializer,rules) {

                  return {
                    type:        "grammar",
                    initializer: initializer !== "" ? initializer : null,
                    rules:       rules
                  };

          })($ctx.initializer,$ctx.rules);
        }
      ],
      "initializer": [
        function($ctx) {
          // initializer[0]
          return (function(code) {

                  return {
                    type: "initializer",
                    code: code
                  };

          })($ctx.code);
        }
      ],
      "rule": [
        function($ctx) {
          // rule[0]
          return (function(name,displayName,expression) {

                  return {
                    type:        "rule",
                    name:        name,
                    expression:  displayName !== ""
                      ? {
                          type:       "named",
                          name:       displayName,
                          expression: expression
                        }
                      : expression
                  };

          })($ctx.name,$ctx.displayName,$ctx.expression);
        }
      ],
      "choice": [
        function($ctx) {
          // choice[0]
          return (function(head,tail) {

                  if (tail.length > 0) {
                    var alternatives = [head].concat(utils.map(
                        tail,
                        function(element) { return element[1]; }
                    ));
                    return {
                      type:         "choice",
                      alternatives: alternatives
                    };
                  } else {
                    return head;
                  }

          })($ctx.head,$ctx.tail);
        }
      ],
      "sequence": [
        function($ctx) {
          // sequence[0]
          return (function(elements,code) {

                  var expression = elements.length !== 1
                    ? {
                        type:     "sequence",
                        elements: elements
                      }
                    : elements[0];
                  return {
                    type:       "action",
                    expression: expression,
                    code:       code
                  };

          })($ctx.elements,$ctx.code);
        },
        function($ctx) {
          // sequence[1]
          return (function(elements) {

                  return elements.length !== 1
                    ? {
                        type:     "sequence",
                        elements: elements
                      }
                    : elements[0];

          })($ctx.elements);
        }
      ],
      "labeled": [
        function($ctx) {
          // labeled[0]
          return (function(label,expression) {

                  return {
                    type:       "labeled",
                    label:      label,
                    expression: expression
                  };

          })($ctx.label,$ctx.expression);
        }
      ],
      "prefixed": [
        function($ctx) {
          // prefixed[0]
          return (function(expression) {

                  return {
                    type:       "text",
                    expression: expression
                  };

          })($ctx.expression);
        },
        function($ctx) {
          // prefixed[1]
          return (function(code) {

                  return {
                    type: "semantic_and",
                    code: code
                  };

          })($ctx.code);
        },
        function($ctx) {
          // prefixed[2]
          return (function(expression) {

                  return {
                    type:       "simple_and",
                    expression: expression
                  };

          })($ctx.expression);
        },
        function($ctx) {
          // prefixed[3]
          return (function(code) {

                  return {
                    type: "semantic_not",
                    code: code
                  };

          })($ctx.code);
        },
        function($ctx) {
          // prefixed[4]
          return (function(expression) {

                  return {
                    type:       "simple_not",
                    expression: expression
                  };

          })($ctx.expression);
        }
      ],
      "suffixed": [
        function($ctx) {
          // suffixed[0]
          return (function(expression) {

                  return {
                    type:       "optional",
                    expression: expression
                  };

          })($ctx.expression);
        },
        function($ctx) {
          // suffixed[1]
          return (function(expression) {

                  return {
                    type:       "zero_or_more",
                    expression: expression
                  };

          })($ctx.expression);
        },
        function($ctx) {
          // suffixed[2]
          return (function(expression) {

                  return {
                    type:       "one_or_more",
                    expression: expression
                  };

          })($ctx.expression);
        }
      ],
      "primary": [
        function($ctx) {
          // primary[0]
          return (function(name) {

                  return {
                    type: "rule_ref",
                    name: name
                  };

          })($ctx.name);
        },
        function($ctx) {
          // primary[1]
           return { type: "any" };
        },
        function($ctx) {
          // primary[2]
          return (function(expression) {
             return expression;
          })($ctx.expression);
        }
      ],
      "action": [
        function($ctx) {
          // action[0]
          return (function(braced) {
             return braced.substr(1, braced.length - 2);
          })($ctx.braced);
        }
      ],
      "equals": [
        function($ctx) {
          // equals[0]
           return "=";
        }
      ],
      "colon": [
        function($ctx) {
          // colon[0]
           return ":";
        }
      ],
      "semicolon": [
        function($ctx) {
          // semicolon[0]
           return ";";
        }
      ],
      "slash": [
        function($ctx) {
          // slash[0]
           return "/";
        }
      ],
      "and": [
        function($ctx) {
          // and[0]
           return "&";
        }
      ],
      "not": [
        function($ctx) {
          // not[0]
           return "!";
        }
      ],
      "dollar": [
        function($ctx) {
          // dollar[0]
           return "$";
        }
      ],
      "question": [
        function($ctx) {
          // question[0]
           return "?";
        }
      ],
      "star": [
        function($ctx) {
          // star[0]
           return "*";
        }
      ],
      "plus": [
        function($ctx) {
          // plus[0]
           return "+";
        }
      ],
      "lparen": [
        function($ctx) {
          // lparen[0]
           return "(";
        }
      ],
      "rparen": [
        function($ctx) {
          // rparen[0]
           return ")";
        }
      ],
      "dot": [
        function($ctx) {
          // dot[0]
           return ".";
        }
      ],
      "identifier": [
        function($ctx) {
          // identifier[0]
          return (function(chars) {
             return chars;
          })($ctx.chars);
        }
      ],
      "literal": [
        function($ctx) {
          // literal[0]
          return (function(value,flags) {

                  return {
                    type:       "literal",
                    value:      value,
                    ignoreCase: flags === "i"
                  };

          })($ctx.value,$ctx.flags);
        }
      ],
      "string": [
        function($ctx) {
          // string[0]
          return (function(string) {
             return string;
          })($ctx.string);
        }
      ],
      "doubleQuotedString": [
        function($ctx) {
          // doubleQuotedString[0]
          return (function(chars) {
             return chars.join("");
          })($ctx.chars);
        }
      ],
      "simpleDoubleQuotedCharacter": [
        function($ctx) {
          // simpleDoubleQuotedCharacter[0]
          return (function(char_) {
             return char_;
          })($ctx.char_);
        }
      ],
      "singleQuotedString": [
        function($ctx) {
          // singleQuotedString[0]
          return (function(chars) {
             return chars.join("");
          })($ctx.chars);
        }
      ],
      "simpleSingleQuotedCharacter": [
        function($ctx) {
          // simpleSingleQuotedCharacter[0]
          return (function(char_) {
             return char_;
          })($ctx.char_);
        }
      ],
      "class": [
        function($ctx) {
          // class[0]
          return (function(inverted,parts,flags) {

                  var partsConverted = utils.map(parts, function(part) { return part.data; });
                  var rawText = "["
                    + inverted
                    + utils.map(parts, function(part) { return part.rawText; }).join("")
                    + "]"
                    + flags;

                  return {
                    type:       "class",
                    parts:      partsConverted,
                    // FIXME: Get the raw text from the input directly.
                    rawText:    rawText,
                    inverted:   inverted === "^",
                    ignoreCase: flags === "i"
                  };

          })($ctx.inverted,$ctx.parts,$ctx.flags);
        }
      ],
      "classCharacterRange": [
        function($ctx) {
          // classCharacterRange[0]
          return (function(begin,end) {

                  if (begin.data.charCodeAt(0) > end.data.charCodeAt(0)) {
                    throw new this.SyntaxError(
                      "Invalid character range: " + begin.rawText + "-" + end.rawText + "."
                    );
                  }

                  return {
                    data:    [begin.data, end.data],
                    // FIXME: Get the raw text from the input directly.
                    rawText: begin.rawText + "-" + end.rawText
                  };

          })($ctx.begin,$ctx.end);
        }
      ],
      "classCharacter": [
        function($ctx) {
          // classCharacter[0]
          return (function(char_) {

                  return {
                    data:    char_,
                    // FIXME: Get the raw text from the input directly.
                    rawText: utils.quoteForRegexpClass(char_)
                  };

          })($ctx.char_);
        }
      ],
      "simpleBracketDelimitedCharacter": [
        function($ctx) {
          // simpleBracketDelimitedCharacter[0]
          return (function(char_) {
             return char_;
          })($ctx.char_);
        }
      ],
      "simpleEscapeSequence": [
        function($ctx) {
          // simpleEscapeSequence[0]
          return (function(char_) {

                  return char_
                    .replace("b", "\b")
                    .replace("f", "\f")
                    .replace("n", "\n")
                    .replace("r", "\r")
                    .replace("t", "\t")
                    .replace("v", "\x0B"); // IE does not recognize "\v".

          })($ctx.char_);
        }
      ],
      "zeroEscapeSequence": [
        function($ctx) {
          // zeroEscapeSequence[0]
           return "\x00";
        }
      ],
      "hexEscapeSequence": [
        function($ctx) {
          // hexEscapeSequence[0]
          return (function(digits) {

                  return String.fromCharCode(parseInt(digits, 16));

          })($ctx.digits);
        }
      ],
      "unicodeEscapeSequence": [
        function($ctx) {
          // unicodeEscapeSequence[0]
          return (function(digits) {

                  return String.fromCharCode(parseInt(digits, 16));

          })($ctx.digits);
        }
      ],
      "eolEscapeSequence": [
        function($ctx) {
          // eolEscapeSequence[0]
          return (function(eol) {
             return eol;
          })($ctx.eol);
        }
      ],
    };

  }; })();

  // $f and $ctx variables are named so creepy just to ensure that parser writer will not use them
  // for naming variables in his code (only $ctx may clash in this architecture, in fact),
  // we hope any modern environment supports Unicode now
  var $f = null; // holds a pointer to current rule blocks, will be initialized in parse() function

  /* ########### PARSER ########### */

  var __parser = function() {

  /* =========== PARSER-DEPENDENT CODE =========== */

    /* ----------- RULES DEFINITIONS ----------- */

    var rules = {}; (function() {

    rules.grammar = function() {
      var _code = $f.grammar;
      return (
        action(
          seqnc(
            ref(rules.__),
            label("initializer",
              maybe(
                ref(rules.initializer)
              )
            ),
            label("rules",
              some(
                ref(rules.rule)
              )
            )
          ),
          /*{
                return {
                  type:        "grammar",
                  initializer: initializer !== "" ? initializer : null,
                  rules:       rules
                };
              }*/
          _code[0])
      ());
    };

    rules.initializer = function() {
      var _code = $f.initializer;
      return (
        action(
          seqnc(
            label("code",
              ref(rules.action)
            ),
            maybe(
              ref(rules.semicolon)
            )
          ),
          /*{
                return {
                  type: "initializer",
                  code: code
                };
              }*/
          _code[0])
      ());
    };

    rules.rule = function() {
      var _code = $f.rule;
      return (
        action(
          seqnc(
            label("name",
              ref(rules.identifier)
            ),
            label("displayName",
              maybe(
                ref(rules.string)
              )
            ),
            ref(rules.equals),
            label("expression",
              ref(rules.choice)
            ),
            maybe(
              ref(rules.semicolon)
            )
          ),
          /*{
                return {
                  type:        "rule",
                  name:        name,
                  expression:  displayName !== ""
                    ? {
                        type:       "named",
                        name:       displayName,
                        expression: expression
                      }
                    : expression
                };
              }*/
          _code[0])
      ());
    };

    rules.choice = function() {
      var _code = $f.choice;
      return (
        action(
          seqnc(
            label("head",
              ref(rules.sequence)
            ),
            label("tail",
              any(
                seqnc(
                  ref(rules.slash),
                  ref(rules.sequence)
                )
              )
            )
          ),
          /*{
                if (tail.length > 0) {
                  var alternatives = [head].concat(utils.map(
                      tail,
                      function(element) { return element[1]; }
                  ));
                  return {
                    type:         "choice",
                    alternatives: alternatives
                  };
                } else {
                  return head;
                }
              }*/
          _code[0])
      ());
    };

    rules.sequence = function() {
      var _code = $f.sequence;
      return (
        choice(
          action(
            seqnc(
              label("elements",
                any(
                  ref(rules.labeled)
                )
              ),
              label("code",
                ref(rules.action)
              )
            ),
            /*{
                  var expression = elements.length !== 1
                    ? {
                        type:     "sequence",
                        elements: elements
                      }
                    : elements[0];
                  return {
                    type:       "action",
                    expression: expression,
                    code:       code
                  };
                }*/
            _code[0]),
          action(
            label("elements",
              any(
                ref(rules.labeled)
              )
            ),
            /*{
                  return elements.length !== 1
                    ? {
                        type:     "sequence",
                        elements: elements
                      }
                    : elements[0];
                }*/
            _code[1])
        )
      ());
    };

    rules.labeled = function() {
      var _code = $f.labeled;
      return (
        choice(
          action(
            seqnc(
              label("label",
                ref(rules.identifier)
              ),
              ref(rules.colon),
              label("expression",
                ref(rules.prefixed)
              )
            ),
            /*{
                  return {
                    type:       "labeled",
                    label:      label,
                    expression: expression
                  };
                }*/
            _code[0]),
          ref(rules.prefixed)
        )
      ());
    };

    rules.prefixed = function() {
      var _code = $f.prefixed;
      return (
        choice(
          action(
            seqnc(
              ref(rules.dollar),
              label("expression",
                ref(rules.suffixed)
              )
            ),
            /*{
                  return {
                    type:       "text",
                    expression: expression
                  };
                }*/
            _code[0]),
          action(
            seqnc(
              ref(rules.and),
              label("code",
                ref(rules.action)
              )
            ),
            /*{
                  return {
                    type: "semantic_and",
                    code: code
                  };
                }*/
            _code[1]),
          action(
            seqnc(
              ref(rules.and),
              label("expression",
                ref(rules.suffixed)
              )
            ),
            /*{
                  return {
                    type:       "simple_and",
                    expression: expression
                  };
                }*/
            _code[2]),
          action(
            seqnc(
              ref(rules.not),
              label("code",
                ref(rules.action)
              )
            ),
            /*{
                  return {
                    type: "semantic_not",
                    code: code
                  };
                }*/
            _code[3]),
          action(
            seqnc(
              ref(rules.not),
              label("expression",
                ref(rules.suffixed)
              )
            ),
            /*{
                  return {
                    type:       "simple_not",
                    expression: expression
                  };
                }*/
            _code[4]),
          ref(rules.suffixed)
        )
      ());
    };

    rules.suffixed = function() {
      var _code = $f.suffixed;
      return (
        choice(
          action(
            seqnc(
              label("expression",
                ref(rules.primary)
              ),
              ref(rules.question)
            ),
            /*{
                  return {
                    type:       "optional",
                    expression: expression
                  };
                }*/
            _code[0]),
          action(
            seqnc(
              label("expression",
                ref(rules.primary)
              ),
              ref(rules.star)
            ),
            /*{
                  return {
                    type:       "zero_or_more",
                    expression: expression
                  };
                }*/
            _code[1]),
          action(
            seqnc(
              label("expression",
                ref(rules.primary)
              ),
              ref(rules.plus)
            ),
            /*{
                  return {
                    type:       "one_or_more",
                    expression: expression
                  };
                }*/
            _code[2]),
          ref(rules.primary)
        )
      ());
    };

    rules.primary = function() {
      var _code = $f.primary;
      return (
        choice(
          action(
            seqnc(
              label("name",
                ref(rules.identifier)
              ),
              not(
                seqnc(
                  maybe(
                    ref(rules.string)
                  ),
                  ref(rules.equals)
                )
              )
            ),
            /*{
                  return {
                    type: "rule_ref",
                    name: name
                  };
                }*/
            _code[0]),
          ref(rules.literal),
          ref(rules.class),
          action(
            ref(rules.dot),
            /*{ return { type: "any" }; }*/
            _code[1]),
          action(
            seqnc(
              ref(rules.lparen),
              label("expression",
                ref(rules.choice)
              ),
              ref(rules.rparen)
            ),
            /*{ return expression; }*/
            _code[2])
        )
      ());
    };

    rules.action = function() {
      var _code = $f.action;
      return (
        as("action",
          action(
            seqnc(
              label("braced",
                ref(rules.braced)
              ),
              ref(rules.__)
            ),
            /*{ return braced.substr(1, braced.length - 2); }*/
            _code[0])
        )
      ());
    };

    rules.braced = function() {
      return (
        text(
          seqnc(
            match("{"),
            any(
              choice(
                ref(rules.braced),
                ref(rules.nonBraceCharacters)
              )
            ),
            match("}")
          )
        )
      ());
    };

    rules.nonBraceCharacters = function() {
      return (
        some(
          ref(rules.nonBraceCharacter)
        )
      ());
    };

    rules.nonBraceCharacter = function() {
      return (
        re(/^[^{}]/, "[^{}]")
      ());
    };

    rules.equals = function() {
      var _code = $f.equals;
      return (
        action(
          seqnc(
            match("="),
            ref(rules.__)
          ),
          /*{ return "="; }*/
          _code[0])
      ());
    };

    rules.colon = function() {
      var _code = $f.colon;
      return (
        action(
          seqnc(
            match(":"),
            ref(rules.__)
          ),
          /*{ return ":"; }*/
          _code[0])
      ());
    };

    rules.semicolon = function() {
      var _code = $f.semicolon;
      return (
        action(
          seqnc(
            match(";"),
            ref(rules.__)
          ),
          /*{ return ";"; }*/
          _code[0])
      ());
    };

    rules.slash = function() {
      var _code = $f.slash;
      return (
        action(
          seqnc(
            match("/"),
            ref(rules.__)
          ),
          /*{ return "/"; }*/
          _code[0])
      ());
    };

    rules.and = function() {
      var _code = $f.and;
      return (
        action(
          seqnc(
            match("&"),
            ref(rules.__)
          ),
          /*{ return "&"; }*/
          _code[0])
      ());
    };

    rules.not = function() {
      var _code = $f.not;
      return (
        action(
          seqnc(
            match("!"),
            ref(rules.__)
          ),
          /*{ return "!"; }*/
          _code[0])
      ());
    };

    rules.dollar = function() {
      var _code = $f.dollar;
      return (
        action(
          seqnc(
            match("$"),
            ref(rules.__)
          ),
          /*{ return "$"; }*/
          _code[0])
      ());
    };

    rules.question = function() {
      var _code = $f.question;
      return (
        action(
          seqnc(
            match("?"),
            ref(rules.__)
          ),
          /*{ return "?"; }*/
          _code[0])
      ());
    };

    rules.star = function() {
      var _code = $f.star;
      return (
        action(
          seqnc(
            match("*"),
            ref(rules.__)
          ),
          /*{ return "*"; }*/
          _code[0])
      ());
    };

    rules.plus = function() {
      var _code = $f.plus;
      return (
        action(
          seqnc(
            match("+"),
            ref(rules.__)
          ),
          /*{ return "+"; }*/
          _code[0])
      ());
    };

    rules.lparen = function() {
      var _code = $f.lparen;
      return (
        action(
          seqnc(
            match("("),
            ref(rules.__)
          ),
          /*{ return "("; }*/
          _code[0])
      ());
    };

    rules.rparen = function() {
      var _code = $f.rparen;
      return (
        action(
          seqnc(
            match(")"),
            ref(rules.__)
          ),
          /*{ return ")"; }*/
          _code[0])
      ());
    };

    rules.dot = function() {
      var _code = $f.dot;
      return (
        action(
          seqnc(
            match("."),
            ref(rules.__)
          ),
          /*{ return "."; }*/
          _code[0])
      ());
    };

    rules.identifier = function() {
      var _code = $f.identifier;
      return (
        as("identifier",
          action(
            seqnc(
              label("chars",
                text(
                  seqnc(
                    choice(
                      ref(rules.letter),
                      match("_")
                    ),
                    any(
                      choice(
                        ref(rules.letter),
                        ref(rules.digit),
                        match("_")
                      )
                    )
                  )
                )
              ),
              ref(rules.__)
            ),
            /*{ return chars; }*/
            _code[0])
        )
      ());
    };

    rules.literal = function() {
      var _code = $f.literal;
      return (
        as("literal",
          action(
            seqnc(
              label("value",
                choice(
                  ref(rules.doubleQuotedString),
                  ref(rules.singleQuotedString)
                )
              ),
              label("flags",
                maybe(
                  match("i")
                )
              ),
              ref(rules.__)
            ),
            /*{
                  return {
                    type:       "literal",
                    value:      value,
                    ignoreCase: flags === "i"
                  };
                }*/
            _code[0])
        )
      ());
    };

    rules.string = function() {
      var _code = $f.string;
      return (
        as("string",
          action(
            seqnc(
              label("string",
                choice(
                  ref(rules.doubleQuotedString),
                  ref(rules.singleQuotedString)
                )
              ),
              ref(rules.__)
            ),
            /*{ return string; }*/
            _code[0])
        )
      ());
    };

    rules.doubleQuotedString = function() {
      var _code = $f.doubleQuotedString;
      return (
        action(
          seqnc(
            match("\""),
            label("chars",
              any(
                ref(rules.doubleQuotedCharacter)
              )
            ),
            match("\"")
          ),
          /*{ return chars.join(""); }*/
          _code[0])
      ());
    };

    rules.doubleQuotedCharacter = function() {
      return (
        choice(
          ref(rules.simpleDoubleQuotedCharacter),
          ref(rules.simpleEscapeSequence),
          ref(rules.zeroEscapeSequence),
          ref(rules.hexEscapeSequence),
          ref(rules.unicodeEscapeSequence),
          ref(rules.eolEscapeSequence)
        )
      ());
    };

    rules.simpleDoubleQuotedCharacter = function() {
      var _code = $f.simpleDoubleQuotedCharacter;
      return (
        action(
          seqnc(
            not(
              choice(
                match("\""),
                match("\\"),
                ref(rules.eolChar)
              )
            ),
            label("char_",
              ch()
            )
          ),
          /*{ return char_; }*/
          _code[0])
      ());
    };

    rules.singleQuotedString = function() {
      var _code = $f.singleQuotedString;
      return (
        action(
          seqnc(
            match("'"),
            label("chars",
              any(
                ref(rules.singleQuotedCharacter)
              )
            ),
            match("'")
          ),
          /*{ return chars.join(""); }*/
          _code[0])
      ());
    };

    rules.singleQuotedCharacter = function() {
      return (
        choice(
          ref(rules.simpleSingleQuotedCharacter),
          ref(rules.simpleEscapeSequence),
          ref(rules.zeroEscapeSequence),
          ref(rules.hexEscapeSequence),
          ref(rules.unicodeEscapeSequence),
          ref(rules.eolEscapeSequence)
        )
      ());
    };

    rules.simpleSingleQuotedCharacter = function() {
      var _code = $f.simpleSingleQuotedCharacter;
      return (
        action(
          seqnc(
            not(
              choice(
                match("'"),
                match("\\"),
                ref(rules.eolChar)
              )
            ),
            label("char_",
              ch()
            )
          ),
          /*{ return char_; }*/
          _code[0])
      ());
    };

    rules.class = function() {
      var _code = $f.class;
      return (
        as("character class",
          action(
            seqnc(
              match("["),
              label("inverted",
                maybe(
                  match("^")
                )
              ),
              label("parts",
                any(
                  choice(
                    ref(rules.classCharacterRange),
                    ref(rules.classCharacter)
                  )
                )
              ),
              match("]"),
              label("flags",
                maybe(
                  match("i")
                )
              ),
              ref(rules.__)
            ),
            /*{
                  var partsConverted = utils.map(parts, function(part) { return part.data; });
                  var rawText = "["
                    + inverted
                    + utils.map(parts, function(part) { return part.rawText; }).join("")
                    + "]"
                    + flags;

                  return {
                    type:       "class",
                    parts:      partsConverted,
                    // FIXME: Get the raw text from the input directly.
                    rawText:    rawText,
                    inverted:   inverted === "^",
                    ignoreCase: flags === "i"
                  };
                }*/
            _code[0])
        )
      ());
    };

    rules.classCharacterRange = function() {
      var _code = $f.classCharacterRange;
      return (
        action(
          seqnc(
            label("begin",
              ref(rules.classCharacter)
            ),
            match("-"),
            label("end",
              ref(rules.classCharacter)
            )
          ),
          /*{
                if (begin.data.charCodeAt(0) > end.data.charCodeAt(0)) {
                  throw new this.SyntaxError(
                    "Invalid character range: " + begin.rawText + "-" + end.rawText + "."
                  );
                }

                return {
                  data:    [begin.data, end.data],
                  // FIXME: Get the raw text from the input directly.
                  rawText: begin.rawText + "-" + end.rawText
                };
              }*/
          _code[0])
      ());
    };

    rules.classCharacter = function() {
      var _code = $f.classCharacter;
      return (
        action(
          label("char_",
            ref(rules.bracketDelimitedCharacter)
          ),
          /*{
                return {
                  data:    char_,
                  // FIXME: Get the raw text from the input directly.
                  rawText: utils.quoteForRegexpClass(char_)
                };
              }*/
          _code[0])
      ());
    };

    rules.bracketDelimitedCharacter = function() {
      return (
        choice(
          ref(rules.simpleBracketDelimitedCharacter),
          ref(rules.simpleEscapeSequence),
          ref(rules.zeroEscapeSequence),
          ref(rules.hexEscapeSequence),
          ref(rules.unicodeEscapeSequence),
          ref(rules.eolEscapeSequence)
        )
      ());
    };

    rules.simpleBracketDelimitedCharacter = function() {
      var _code = $f.simpleBracketDelimitedCharacter;
      return (
        action(
          seqnc(
            not(
              choice(
                match("]"),
                match("\\"),
                ref(rules.eolChar)
              )
            ),
            label("char_",
              ch()
            )
          ),
          /*{ return char_; }*/
          _code[0])
      ());
    };

    rules.simpleEscapeSequence = function() {
      var _code = $f.simpleEscapeSequence;
      return (
        action(
          seqnc(
            match("\\"),
            not(
              choice(
                ref(rules.digit),
                match("x"),
                match("u"),
                ref(rules.eolChar)
              )
            ),
            label("char_",
              ch()
            )
          ),
          /*{
                return char_
                  .replace("b", "\b")
                  .replace("f", "\f")
                  .replace("n", "\n")
                  .replace("r", "\r")
                  .replace("t", "\t")
                  .replace("v", "\x0B"); // IE does not recognize "\v".
              }*/
          _code[0])
      ());
    };

    rules.zeroEscapeSequence = function() {
      var _code = $f.zeroEscapeSequence;
      return (
        action(
          seqnc(
            match("\\0"),
            not(
              ref(rules.digit)
            )
          ),
          /*{ return "\x00"; }*/
          _code[0])
      ());
    };

    rules.hexEscapeSequence = function() {
      var _code = $f.hexEscapeSequence;
      return (
        action(
          seqnc(
            match("\\x"),
            label("digits",
              text(
                seqnc(
                  ref(rules.hexDigit),
                  ref(rules.hexDigit)
                )
              )
            )
          ),
          /*{
                return String.fromCharCode(parseInt(digits, 16));
              }*/
          _code[0])
      ());
    };

    rules.unicodeEscapeSequence = function() {
      var _code = $f.unicodeEscapeSequence;
      return (
        action(
          seqnc(
            match("\\u"),
            label("digits",
              text(
                seqnc(
                  ref(rules.hexDigit),
                  ref(rules.hexDigit),
                  ref(rules.hexDigit),
                  ref(rules.hexDigit)
                )
              )
            )
          ),
          /*{
                return String.fromCharCode(parseInt(digits, 16));
              }*/
          _code[0])
      ());
    };

    rules.eolEscapeSequence = function() {
      var _code = $f.eolEscapeSequence;
      return (
        action(
          seqnc(
            match("\\"),
            label("eol",
              ref(rules.eol)
            )
          ),
          /*{ return eol; }*/
          _code[0])
      ());
    };

    rules.digit = function() {
      return (
        re(/^[0-9]/, "[0-9]")
      ());
    };

    rules.hexDigit = function() {
      return (
        re(/^[0-9a-fA-F]/, "[0-9a-fA-F]")
      ());
    };

    rules.letter = function() {
      return (
        choice(
          ref(rules.lowerCaseLetter),
          ref(rules.upperCaseLetter)
        )
      ());
    };

    rules.lowerCaseLetter = function() {
      return (
        re(/^[a-z]/, "[a-z]")
      ());
    };

    rules.upperCaseLetter = function() {
      return (
        re(/^[A-Z]/, "[A-Z]")
      ());
    };

    rules.__ = function() {
      return (
        any(
          choice(
            ref(rules.whitespace),
            ref(rules.eol),
            ref(rules.comment)
          )
        )
      ());
    };

    rules.comment = function() {
      return (
        as("comment",
          choice(
            ref(rules.singleLineComment),
            ref(rules.multiLineComment)
          )
        )
      ());
    };

    rules.singleLineComment = function() {
      return (
        seqnc(
          match("//"),
          any(
            seqnc(
              not(
                ref(rules.eolChar)
              ),
              ch()
            )
          )
        )
      ());
    };

    rules.multiLineComment = function() {
      return (
        seqnc(
          match("/*"),
          any(
            seqnc(
              not(
                match("*/")
              ),
              ch()
            )
          ),
          match("*/")
        )
      ());
    };

    rules.eol = function() {
      return (
        as("end of line",
          choice(
            match("\n"),
            match("\r\n"),
            match("\r"),
            match("\u2028"),
            match("\u2029")
          )
        )
      ());
    };

    rules.eolChar = function() {
      return (
        re(/^[\n\r\u2028\u2029]/, "[\\n\\r\\u2028\\u2029]")
      ());
    };

    rules.whitespace = function() {
      return (
        as("whitespace",
          re(/^[ \t\x0B\f\xA0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/, "[ \\t\\x0B\\f\\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]")
        )
      ());
    };

    })();

    /* ----------- OPERATORS ----------- */

    // get current char
    function cc() { return (pos < ilen) ? input.charAt(pos) : EOI; }

    var ref = def(inctx); // will call rule inside context

    function action(f, code) {
      return inctx(function() {
        p_pos = pos; var res; // save previous position
        f(); res = code(cctx);
        if (res === null) { pos = p_pos;
           failed(SOMETHING, NOTHING); }
        return res;
      });
    }
    action = def(action);

    function seqnc(/*f...*/) {
      var p_pos = pos; // save previous position locally
      var fs = arguments,
          s = [],
          on_miss = function(e) {
                        pos = p_pos; throw e; };
      for (var fi = 0, fl = fs.length;
           fi < fl; fi++) {
        s.push(safe(fs[fi], on_miss));
      }
      return s;
    }
    seqnc = def(seqnc);

    function as(name, f) {
      alias = name; var res = f();
      alias = ''; return res;
    }
    as = def(as);

    function choice(/*f...*/) {
      var fs = arguments,
          missed = 0,
          my_e = null,
          on_miss = function(e) {
            my_e = e; missed = 1;
          };
      for (var fi = 0, fl = fs.length;
           fi < fl; fi++) {
        var res = safe(fs[fi], on_miss);
        if (!missed) return res;
        missed = 0;
      }
      throw my_e;
    }
    choice = def(choice);

    function match(str) {
      var slen = str.length;
      if ((pos + slen) > ilen) {
        failed(quote(str), EOI); // exits
      }
      if (input.substr(pos, slen) === str) {
        pos += slen;
        return str;
      }
      failed(quote(str), cc());
    }
    match = def(match);

    function label(lbl, f) {
      return cctx[lbl] = f();
    }
    label = def(label);

    function text(f) {
      var p_pos = pos; // save previous position locally
      f(); return input.substr(p_pos,pos-p_pos);
    }
    text = def(text);

    function some(f) {
      return [f()].concat(any(f)());
    }
    some = def(some);

    function any(f) {
      var s = [],
          missed = 0,
          on_miss = function() { missed = 1; };
      while (!missed) {
        s.push(safe(f, on_miss));
      }
      if (missed) s.splice(-1);
      return s;
    }
    any = def(any);

    function maybe(f) {
      var missed = 0,
          res = safe(f, function() {
        missed = 1;
      });
      if (missed) return '';
      return res;
    }
    maybe = def(maybe);

    function not(f) {
      // save previous position locally
      var p_pos = pos, missed = 0;
      nr = 1; safe(f, function() {
        missed = 1;
      }); nr = 0;
      pos = p_pos;
      if (missed) return '';
      failed(EOI, cc());
    }
    not = def(not);

    function re(rx, desc) {
      var res, desc = desc || rx.source;
      if (res = rx.exec(input.substr(pos))) {
         if (res.index !== 0) failed(desc, cc());
         pos += res[0].length;
         return res[0];
      } else failed(desc, cc());
    }
    re = def(re);

    function ch() { // char
      if (pos >= ilen) failed(ANY, EOI);
      return input[pos++];
    }
    ch = def(ch);

  /* =========== PARSER-INDEPENDENT CODE =========== */

    /* ----------- VARIABLES ----------- */

    var ctx, // { ... }, root of the context
        cctx; // { ... }, current context pointer

    var current, // '-', current rule name
        alias; // '', current rule alias, if defined

    var failures, // {}, failures data
        rmfpos, // 0, rightmost failure position
        nr; // 0, no-report, fire errors w/o reporting

    var /*input, */ilen; // input, input length

    /* ----------- CONTEXT ----------- */

    function prepare_ctx() { return ctx_lvl(); }
    function ctx_lvl(parent) {
      function CtxLevel() {
          this.__p = parent;
          this.__c = null;
      }
      CtxLevel.prototype = parent;
      return new CtxLevel();
    }
    function din() {  // dive in
      if (!cctx.__c) cctx.__c = ctx_lvl(cctx);
      cctx = cctx.__c;
    }
    function dout() { // dive out
      if (!cctx.__p) throw new Error('reached top context level');
      cctx = cctx.__p;
    }
    function inctx(f) { // execute in own context and return
      var r, e;
      din(); r = safe(f, function(err) { e = err; });
      dout(); if (e) throw e;
      return r;
    }

    /* ----------- DEFERRED ----------- */
    // Makes passed function to save its argument values,
    // but not execute until specially requested

    function def(f) {
      return function() {
        return (function(f, args) {
          return function() { return f.apply(null, args); };
        })(f, arguments);
      };
    }

    /* ----------- RULES WRAPPER ----------- */

    function wrap(name, rule) {
      return function() { current = name; return rule(); };
    }
    for (var rule in rules) {
      rules[rule] = wrap(rule, rules[rule]);
    }

    /* ----------- RESULT OBJECT + PARSE FUNCTION ----------- */

    var result = {
      /*
       * Parses the input with a generated parser. If the parsing is successfull,
       * returns a value explicitly or implicitly specified by the grammar from
       * which the parser was generated (see |PEG.buildParser|). If the parsing is
       * unsuccessful, throws |PEG.parser.MatchFailed| describing the error.
       */
      parse: function(_input, _opts) {

        // initialize variables
        pos = 0, p_pos = 0, input = _input, options = _opts || {};

        ilen = input.length, failures = {}, rmfpos = 0, nr = 0;

        ctx = prepare_ctx(), cctx = ctx;

        current = '-';

        var startRule = options.startRule || "grammar";
        if (["grammar"].indexOf(startRule) < 0) {
          throw new Error("Can't start parsing from rule " + quote(startRule) + ".");
        }

        // call user initializer and also
        // get blocks lying in the same context
        $f = __p_blocks();

        // find start rule
        if (startRule) {
          if (rules[startRule] === undefined) {
            throw new SyntaxError("Rule not found: " + quote(startRule) + ".");
          }
        } else {
          throw new Error("Start rule is not defined in options, no 'start' rule found and first rule in grammar was empty");
        }

        // and execute it
        var res;
        try {
          res = rules[startRule]();
          if ((pos < ilen) ||
              (res === null)) failed(EOI, cc());
        } catch(e) {
          if (e instanceof _MatchFailed) {
            // throw rightmost error instead
            throw adapt(failures[rmfpos]);
          }
          throw e;
        }

        return res;
      },


      /* makes error type accessible outside */
      MatchFailed: _MatchFailed,
      SyntaxError: _SyntaxError
    };

    /* ----------- UTILS ----------- */

    function Marker(human_str) { this.str=human_str; }
    Marker.prototype.toString = function() { return this.str; };
    var EOI = new Marker('end of input'),
        ANY = new Marker('any character'),
        SOMETHING = new Marker('progress'),
        NOTHING = new Marker('nothing');

    function hexOf(ch) {
      var x = ch.charCodeAt(0),
          v = x.toString(16).toUpperCase(),
          h = (x > 0xFF),
          i = (h ? 4 : 2) - v.length;
      while (i--) v = v + '0';
      return '\\' + (h ? 'u' : 'x') + v;
    }

    function quote(s) {
      /*
       * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
       * string literal except for the closing quote character, backslash,
       * carriage return, line separator, paragraph separator, and line feed.
       * Any character may appear in the form of an escape sequence.
       *
       * For portability, we also escape escape all control and non-ASCII
       * characters. Note that "\0" and "\v" escape sequences are not used
       * because JSHint does not like the first and IE the second.
       */
      return '"' + s
        .replace(/\\/g, '\\\\')  // backslash
        .replace(/"/g, '\\"')    // closing quote character
        .replace(/\x08/g, '\\b') // backspace
        .replace(/\t/g, '\\t')   // horizontal tab
        .replace(/\n/g, '\\n')   // line feed
        .replace(/\f/g, '\\f')   // form feed
        .replace(/\r/g, '\\r')   // carriage return
        .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, hexOf)
        + '"';
    }

    /* ----------- FAILURES ----------- */

    function _MatchFailed(what, found, expected) {
      this.what = what;
      this.expected = expected || [];
      this.found = found;
      this.offset = pos;
      this.xpos = [-1, -1];
      this.line = -1;
      this.column = -1;
    }
    _MatchFailed.prototype = new Error();
    _MatchFailed.prototype.toString =
       function() { return 'MatchFailed: '+emsg(this); };
    var merr = function(fnd, exp) {
      return new _MatchFailed(alias || current, fnd, exp);
    };

    function failed(expected, found) {
      var expected = alias || expected;
      // if no report required, just throw
      if (nr) throw merr(found, [expected]);
      if (pos > rmfpos) rmfpos = pos;
      var e = failures[pos] ||
             (failures[pos] = merr(found));
      /*if (e.found !== found)*/ e.found = found;
      var prev = e.expected;
      var f; for (var i = prev.length; i--;) {
        if (prev[i] === expected) {
          f = 1; break;
        }
      }; if (!f) prev.push(expected);
      throw e;
    }

    function safe(f, callback) {
      try { return f();
      } catch(e) {
        if (e instanceof _MatchFailed) {
          if (callback) callback(e);
        } else { throw e; }
      }
    }

    function emsg(e) {
      var found_str, exp_str;
      if (e.found instanceof Marker) {
        found_str = e.found.str;
      } else {
        found_str = quote(e.found);
      }
      if (e.expected instanceof Marker) {
        exp_str = e.expected.str;
      } else if ((e.expected.length === 1) &&
          (e.expected[0] instanceof Marker)) {
        exp_str = e.expected[0].str;
      } else {
        var xs = e.expected;
        exp_str = ((xs.length > 1)
                  ? (xs.slice(0,-1).join(', ')+' '+
                    'or '+xs.slice(-1))
                  : xs[0]);
      }
      return /*'Stopped at '+quote(e.what)+': */'Expected '+exp_str+
             ' but '+found_str+' found.';
    }
    function adapt(e) {
      e.message = emsg(e);
      if ((e.found instanceof Marker) && (e.found === EOI)) e.found = null;
      var xs = e.expected.sort();
      if ((xs.length === 1) &&
          (xs[0] === EOI)) {
        e.expected = [];
      }
      for (var i = xs.length; i--;)
        { if (xs[i] instanceof Marker) xs[i] = xs[i].str; }
      return e;
    }

    function _SyntaxError(msg) { // may be thrown from parser
      this.message = msg;
    }
    _SyntaxError.prototype = new Error();
    _SyntaxError.prototype.toString =
       function() { return 'SyntaxError: '+this.message; };

    /* ---------- RETURN RESULT OBJECT ----------- */

    return result;

  };


  /* ----------- RETURN PARSER ----------- */
  return __parser();

})();
